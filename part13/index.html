<!DOCTYPE html>
<html>
  <head>
    <title>Ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi, syksy 2017 | Osa 13</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

    <link href="../stylesheets/styles-d08f7ac6.css" rel="stylesheet" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/xcode.min.css">

    <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.css" />

    <link rel="stylesheet" href="https://materiaalit.github.io/code-states-visualizer-cdn/app.css" />
    <link rel="stylesheet" href="https://materiaalit.github.io/typonator-cdn/app.css" />
    <link rel="stylesheet" href="https://crowdsorcerer.testmycode.io/dist/app.css" />

      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-47575342-8', 'auto');
  ga('send', 'pageview');
</script>

  </head>
  <body>
    <div class="main-wrapper">
      <div class="header-wrapper">
        <div class="browser-support-warning" id="browser-support-warning" style="display: none;">
  Kaikki tämän materiaalin osat eivät välttämättä tuo nykyistä selaintasi. Voisitko harkita vaihtamista <a href="https://www.google.com/chrome/browser/desktop/" target="_blank" rel="noopener">Chrome</a> tai <a href="https://www.mozilla.org/en-US/firefox/new/" target="_blank" rel="noopener">Firefox</a> selaimeen?
  <span class="browser-support-warning__close">Selvä!</span>
</div>


        <nav class="navbar navbar-light bg-white">
  <a class="navbar-brand" href="http://mooc.fi" alt="MOOC" target="_blank" rel="noopener">
    <span class="icon-mooc"></span>
  </a>

  <ul class="nav navbar-nav hidden-md-down">
      <li class="nav-item ">
        <a href="../" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=index.html&gt;')">Johdanto</a>
      </li>
      <li class="nav-item ">
        <a href="../part1/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part1.html&gt;')">Osa 1</a>
      </li>
      <li class="nav-item ">
        <a href="../part2/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part2.html&gt;')">Osa 2</a>
      </li>
      <li class="nav-item ">
        <a href="../part3/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part3.html&gt;')">Osa 3</a>
      </li>
      <li class="nav-item ">
        <a href="../part4/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part4.html&gt;')">Osa 4</a>
      </li>
      <li class="nav-item ">
        <a href="../part5/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part5.html&gt;')">Osa 5</a>
      </li>
      <li class="nav-item ">
        <a href="../part6/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part6.html&gt;')">Osa 6</a>
      </li>
      <li class="nav-item ">
        <a href="../part7/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part7.html&gt;')">Osa 7</a>
      </li>
      <li class="nav-item ">
        <a href="../part8/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part8.html&gt;')">Osa 8</a>
      </li>
      <li class="nav-item ">
        <a href="../part9/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part9.html&gt;')">Osa 9</a>
      </li>
      <li class="nav-item ">
        <a href="../part10/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part10.html&gt;')">Osa 10</a>
      </li>
      <li class="nav-item ">
        <a href="../part11/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part11.html&gt;')">Osa 11</a>
      </li>
      <li class="nav-item ">
        <a href="../part12/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part12.html&gt;')">Osa 12</a>
      </li>
      <li class="nav-item active">
        <a href="./" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part13.html&gt;')">Osa 13</a>
      </li>
      <li class="nav-item ">
        <a href="../part14/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part14.html&gt;')">Osa 14</a>
      </li>
      <li class="nav-item ">
        <a href="../partX/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=partX.html&gt;')">Osa X</a>
      </li>
  </ul>

  <div class="float-xs-right navbar__buttons">
    <div class="dropdown" id="mobile-nav-dropdown">
      <button class="btn btn-secondary dropdown-toggle navbar__mobile-nav-toggle" data-toggle="dropdown">
        <i class="fa fa-bars"></i>
      </button>

      <div class="dropdown-menu">
      </div>
    </div>

    <a href="https://riot.im/app/#/room/#mooc.fi:matrix.org" target="_blank" rel="noopener" class="btn btn-secondary">
      <span class="hidden-md-down">Chat</span>
      <i class="fa fa-commenting-o hidden-lg-up"></i>
    </a>

    <button class="btn btn-secondary" id="table-of-contents-toggle">
      <span class="hidden-md-down">Sisällysluettelo</span>
      <i class="fa fa-ellipsis-h hidden-lg-up"></i>
    </button>

    <button class="btn btn-primary" id="tmc-login-toggle">Kirjaudu sisään</button>
  </div>
</nav>

      </div>

      <div class="content-wrapper">
        <div class="container material" id="material">
            <div class="exercise-list">
  <div class="exercise-list__header">
    Tehtävät
  </div>

  <div class="exercise-list__content" id="exercise-list"></div>

    <div class="exercise-list__quiznator">
      <div class="quiznator-dashboard"></div>

    </div>
</div>


          <div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Kolmannentoista osan tavoitteet
  </div>

  <div class="hint__body">
    
  <p>
    Osaa näyttää kuvia sekä soittaa äänitiedostoja. Luo suuremman ohjelman esimerkkiä noudattaen. Osaa tehdä graafista käyttöliittymää käyttävästä ohjelmasta paketin, jonka voi jakaa muille.
  </p>


  </div>
</div>


<h1 class="material-heading">
    Multimedian käyttö sovelluksissa

</h1>

<p>
  Tutustutaan lyhyesti multimedian käyttöön JavaFX-sovelluksissa.
</p>

<h2 class="material-heading">
    Kuvat

</h2>

<p>
  Kuvan näyttämiseen osana sovellusta on useita tapoja. Eräs suoraviivainen lähestymistapa hyödyntää JavaFx:n <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/Image.html" target="_blank">Image</a> ja <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/image/ImageView.html" target="_blank">ImageView</a> luokkia.
</p>

<p>
  Image-luokalle annetaan parametrina avattavan kuvatiedoston nimi -- nimeä tulee edeltää etuliite <code>file:</code>, joka kertoo kuvan olevan tiedosto. Alla olevassa esimerkissä ladataan tiedosto <code>humming.jpg</code>, joka annetaan luotavalle ImageView-oliolle parametrina. Tämän jälkeen ImageView-olio asetetaan Pane-asetteluun -- Pane-asettelu ei ota mm. kantaa sen sisältävien elementtien sijaintiin. Lopulta asettelu asetetaan osaksi Scene-oliota ja se asetetaan näkyville.
</p>

<pre class="sh_java code-highlight"><code>import javafx.application.Application;
import static javafx.application.Application.launch;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

public class KuvaApplication extends Application {

    @Override
    public void start(Stage stage) {

        Image kuvatiedosto = new Image("file:humming.jpg");
        ImageView kuva = new ImageView(kuvatiedosto);

        Pane ruutu = new Pane();
        ruutu.getChildren().add(kuva);

        stage.setScene(new Scene(ruutu));
        stage.show();

    }

    public static void main(String[] args) {
        launch(args);
    }

}
</code></pre>

<p>
  Ohjelman suorittaminen luo seuraavanlaisen ikkunan. Tässä oletetaan, että tiedosto <code>humming.jpg</code> on olemassa, ja että se löytyy projektin juuresta (samasta kansiosta kuin tiedosto <code>pom.xml</code>).
</p>

<img src="../img/material/image-ja-imageview-12272223.png" />

<p>&nbsp;</p>

<p>
  Esimerkissä käytetään <a href="https://www.flickr.com/photos/15323831@N05" target="_blank">Linda Tanner</a>in kuvaa osoitteesta <a href="http://www.freestockphotos.biz/stockphoto/17874" target="_blank">http://www.freestockphotos.biz/stockphoto/17874</a>. Kuva on lisensoitu <a href="https://creativecommons.org/licenses/by/2.0/" target="_blank">Creative Commons CC BY 2.0</a>-lisenssillä.
</p>

<p>
  ImageView-olio tarjoaa joukon menetelmiä kuvan (yksinkertaiseen käsittelyyn). Kuvaa voi muunmuassa kääntää, sen kokoa voi muuttaa, ja sitä voi siirtää ruudulla. Alla olevassa esimerkissä kuva on käännetty ympäri, sen koko on puolitettu, ja sitä on siirretty hieman oikealle.
</p>

<pre class="sh_java code-highlight"><code>@Override
public void start(Stage stage) {

    Image kuvatiedosto = new Image("file:humming.jpg");
    ImageView kuva = new ImageView(kuvatiedosto);
        
    kuva.setRotate(180);
    kuva.setScaleX(0.5);
    kuva.setScaleY(0.5);
        
    kuva.setTranslateX(50);

    Pane ruutu = new Pane();
    ruutu.getChildren().add(kuva);

    stage.setScene(new Scene(ruutu));
    stage.show();

}
</code></pre>

<img src="../img/material/humming-kaannetty-3878e395.png" />

<p>&nbsp;</p>


<p>
  ImageView-luokka tarjoaa pääsyn kuvaan, mutta sen kautta ei pääse yksittäisiin pikseleihin (eli yksittäisiin yhtä väriä sisältäviin pieniin "ruutuihin", joista kuva koostuu). Kuvan yksittäisiä pikseleitä voi lukea Image-oliosta saatavan <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/PixelReader.html" target="_blank">PixelReader</a>-olion avulla. PixelReader-olion avulla voidaan käydä koko kuva läpi pikseli pikseliltä, samalla kuvaa erilliseen <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/WritableImage.html" target="_blank">WritableImage</a>-olioon kirjoittaen.
</p>

<p>
  Alla olevassa esimerkissä kuva kopioidaan pikseli pikseliltä erilliselle WritableImage-oliolle, joka näytetään sovelluksessa.
</p>

<pre class="sh_java code-highlight"><code>@Override
public void start(Stage stage) {

    Image kuvatiedosto = new Image("file:humming.jpg");

    PixelReader lukija = kuvatiedosto.getPixelReader();

    int leveys = (int) kuvatiedosto.getWidth();
    int korkeus = (int) kuvatiedosto.getHeight();

    WritableImage kohdeKuva = new WritableImage(leveys, korkeus);
    PixelWriter kirjoittaja = kohdeKuva.getPixelWriter();

    for (int y = 0; y &lt; korkeus; y++) {
        for (int x = 0; x &lt; leveys; x++) {

            Color vari = lukija.getColor(x, y);
            double punainen = vari.getRed();
            double vihrea = vari.getGreen();
            double sininen = vari.getBlue();
            double lapinakyvyys = vari.getOpacity();

            Color uusiVari = new Color(punainen, vihrea, sininen, lapinakyvyys);

            kirjoittaja.setColor(x, y, uusiVari);
        }
    }

    ImageView kuva = new ImageView(kohdeKuva);

    Pane pane = new Pane();
    pane.getChildren().add(kuva);

    stage.setScene(new Scene(pane));
    stage.show();
}
</code></pre>

<p>
  Kuvan ulkomuoto ei ole muuttunut lainkaan.
</p>

<img src="../img/material/image-ja-imageview-12272223.png" />

<p>&nbsp;</p>

<p>
  Muistellaan kurssin ensimmäistä osaa sekä tehtävää Salapaikka ranskassa. Tehtävässä käsiteltiin kuvankäsittelyyn liittynyttä ohjelmistovirhettä: <em>"Tämä virhe oli aika harmittava. Se muutti kaikki siniset ja vihreät väriarvot pelkäksi kohinaksi, joten niistä ei ole mitään iloa eikä niitä saa koskaan takaisin kuvaan. Lisäksi punaisen värin määrä jokaisessa pikselissä jakautui noin kymmenellä kopioinnin yhteydessä, joten kuvan punainen väri on aivan liian tumma."</em>
</p>

<p>
  Lisätään kuvaan edellinen ohjelmistovirhe, eli muunnetaan siniset ja vihreät väriarvot kohinaksi (satunnaisiksi luvuiksi). Jaetaan myös punaisen värin määrä kymmenellä.
</p>

<pre class="sh_java code-highlight"><code>Random arpoja = new Random();
        
for (int y = 0; y < korkeus; y++) {
    for (int x = 0; x < leveys; x++) {

        Color vari = lukija.getColor(x, y);
        double punainen = vari.getRed() /  10;
        double vihrea = arpoja.nextDouble();
        double sininen = arpoja.nextDouble();
        double lapinakyvyys = vari.getOpacity();

        Color uusiVari = new Color(punainen, vihrea, sininen, lapinakyvyys);

        kirjoittaja.setColor(x, y, uusiVari);
    }
}
</code></pre>

<p>
  Mysteerikuvasta tulee melko tutunnäköinen.
</p>

<img src="../img/material/kuva-mysteeri-9bdef14f.png" />

<p>&nbsp;</p>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Kollaasi</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Andy Warhol tuli tutuksi kuvakollaaseista, joissa yksi tai useampi kuva toistui useampaan otteeseen esimerkiksi eri väreissä.
  </p>

  <p>    
    Tehtäväpohjassa on ohjelma, joka lataa ja näyttää Mona Lisan. Tehtävänäsi on luoda Andy Warholmainen muunnos annetusta kuvasta. Muunnos voi olla esimerkiksi alla olevan kuvan näköinen, tai se voi olla jotain muuta.
  </p>

  <img src="../img/material/monalisa-kollaasi-55d282af.png" />

  <p>
    &nbsp;
  </p>

  <p>
    Vinkki! Kannattaa pyrkiä ensin tilanteeseen, missä kuva toistuu kahdesti, isona ja pienenä. Kts. alla.
  </p>

  <img src="../img/material/monalisa-kollaasi-alku-d9409185.png" />

  <p>
    &nbsp;
  </p>
  
  <p>
    Kun saat muodostettua kollaasin, tehtävää voi jatkaa halutessaan. Voit esimerkiksi etsiä käyttöösi toisen tai useamman kuvan (valitkaa png-muodossa oleva kuva), tai lähteä miettimään parempaa väriä käyttämällenne kuvalle. Alla olevassa esimerkissä väri vaihdettu negatiiviksi -- tämä onnistuu ottamalla jokaisen värin erotus luvusta yksi, esim. <code>punainen = 1.0 - punainen</code>.
  </p>
  
  <img src="../img/material/monalisa-negatiivi-f4d2ca90.png" />

  <p>
    &nbsp;
  </p>

  <p>
    <em>
      Tehtäväpohjan mukana tuleva Mona Lisa -kuva on noudettu Wikimedian osoitteesta <a href="https://commons.wikimedia.org/wiki/Category:Mona_Lisa" target="_blank">https://commons.wikimedia.org/wiki/Category:Mona_Lisa</a>. Käytetty kuva on vapaasti käytettävissä.
    </em>
  </p>
  

    </div>
  </div>
</div>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Matkavalokuvat (2 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Matkailijat tykkäävät ottaa valokuvia. Usein kuvissa sattuu kuitenkin olemaan ärsyttävä turisti, joka on esimerkiksi kuvatun kohteen edessä. Harmitus kasvaa erityisesti, jos samainen turisti esiintyy jokaisessa kuvassa.
  </p>

  <p>
    Alla on kaksi kuvaa eräästä reissusta.
  </p>

  <img src="../img/exercises/06-19-matkavalokuvat-1-7711c160.png"/>

  <p>&nbsp;</p>

  <img src="../img/exercises/06-19-matkavalokuvat-2-bce28fd0.png"/>

  <p>&nbsp;</p>

  <p>
    Täydennetään ohjelmaa, mikä mahdollistaa kuvan katsomisen ilman turistia. Apunamme meillä on iso nippu samasta kohteesta otettuja kuvia (turisti on harmittavasti kylläkin jokaisessa niistä...)
  </p>

  <p>
    Tehtäväpohjassa on valmiina ohjelma, jolla voi tarkastella kuvia. Huomaat, että ohjelmassa käytetty kuvien näyttämistapa poikkeaa hieman edellisistä esimerkeistä -- kuten todettua, lähestymistapoja on useita. Kun ohjelma on käynnissä, painamalla numeronäppäintä saat näkyville kuvalistan tietyssä indeksissä olevan kuvan. Kun painat näppäintä "v", näet kuvan muodossa, missä jokaisen kuvan jokaisesta pikselistä on valittu vaaleimmat pikseliarvot.
  </p>

  <img src="../img/exercises/06-19-matkavalokuvat-vaalein-d5fd76e5.png"/>

  <p>&nbsp;</p>

  <h2>Tummimman värin valinta</h2>

  <p>
    Muokkaa sovellusta siten, että kun käyttäjä painaa näppäintä "t", ohjelma näyttää kuvan, missä näkyy yhdistettävien kuvien tummimmat pikselit. Toteuta tummimman värin valinta luokan Yhdistin metodiin <code>public WritableImage tummin(final ArrayList&lt;Image&gt; kuvat)</code> -- ota mallia metodista <code>vaalein</code>.
  </p>

  <p>
    Kun olet lisännyt tummennustoiminnallisuuden, tumman kuvan pitäisi näyttää kutakuinkin seuraavalta.
  </p>

  <img src="../img/exercises/06-19-matkavalokuvat-tummin-9199df1b.png"/>

  <p>&nbsp;</p>

  <h2>Värien mediaani</h2>

  <p>
    Noniin, hankkiudutaan turistista eroon.
  </p>

  <p>
    Muokkaa sovellusta siten, että kun käyttäjä painaa näppäintä "m", ohjelma näyttää kuvan, missä näkyy yhdistettävien kuvien väriarvojen mediaanit. Toteuta mediaanivärin valinta luokan Yhdistin metodiin <code>public WritableImage mediaani(final ArrayList&lt;Image&gt; kuvat)</code>.
  </p>

  <p>
    Mediaani on järjestettyjen lukujen keskimmäinen arvo. Esimerkiksi, jos viiden kuvan sinisten värien arvot ovat <code>211, 123, 17, 155, 8</code>, on niiden mediaani <code>123</code>. Saat mediaanin selville järjestämällä arvot, ja valitsemalla listan keskimmäisen arvon.
  </p>

  <p>
    Toteutuksen pitäisi poistaa ärsyttävä turisti:
  </p>

  <img src="../img/exercises/06-19-matkavalokuvat-mediaani-667b67eb.png"/>


  <p>
    <em>Tehtävän alkuperäinen versio: John Nicholson / Austin Peay State University</em>
  </p>


    </div>
  </div>
</div>

<h2 class="material-heading">
    Äänet

</h2>

<p>
  Äänitiedostojen käsittelyyn löytyy myös useampia menetelmiä, joista tässä käsitellään yksi tapa. Tapa liittyy äänitiedostojen käsittelyyn äänileikkeinä (audioclip), jotka ovat esimerkiksi ääniefektejä ym.
</p>

<p>
  Esimerkissä käytetään Daniel Simionin <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">Creative Commons Attribution 3.0</a> -lisenssillä julkaisemaa äänitiedostoa. Äänitiedoston voi kuunnella alla. Äänitiedosto on noudettu osoitteessa <a href="http://soundbible.com/" target="_blank">http://soundbible.com/</a> olevasta palvelusta.
</p>

<audio controls>
  <source src="../img/front-desk-bells-daniel_simon.wav" type="audio/wav"/>
</audio>

<p>
  Oletetaan, että tiedoston nimi on <code>bell.wav</code>, ja että se sijaitsee projektin juuressa. Yksinkertaisimmillaan äänen soittaminen tapahtuu seuraavasti.
</p>

<pre>
AudioClip leike = new AudioClip("file:bell.wav");
leike.play();
</pre>

<p>
  AudioClip-olion toiminta on riippuvainen JavaFx:n kirjastoista, joten äänitiedosto tulee käynnistää osana JavaFx-ohjelmaa. Allaoleva esimerkki etsii projektin juuresta tiedostoa <code>bell.wav</code> ja luo siitä äänileikkeen. Tämän jälkeen äänileike soitetaan, ja sovellukseen liittyvä (tyhjä) ikkuna avataan. 
</p>  

<pre class="sh_java code-highlight"><code>import javafx.application.Application;
import static javafx.application.Application.launch;
import javafx.scene.media.AudioClip;
import javafx.stage.Stage;

public class AudioClipApplication extends Application {

    @Override
    public void start(Stage stage) {

        AudioClip leike = new AudioClip("file:bell.wav");
        leike.play();

        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }

}
</code></pre>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Hurraa</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehtäväpohjan juurikansiossa on tiedosto <code>Applause-Yannick_Lemieux.wav</code>, joka sisältää hurrausäänen. Tehtävänäsi on luoda sovellus, missä on "Hurraa"-nappi. Kun käyttäjä painaa nappia, sovelluksen tulee soittaa edellä mainittu äänitiedosto.
  </p>

  <img src="../img/material/hurraa-nappi-990702ff.png"/>

  <p>&nbsp;</p>

  <p>
    <em>
      Äänitiedosto on Yannick Lemieuxin nauhoittama. Tiedosto on lisensoitu Creative Commonsin Attribuutiolisenssillä (<a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">https://creativecommons.org/licenses/by/3.0/</a>).
    </em>
  </p>

    </div>
  </div>
</div>



<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Mediasoittimen luominen
  </div>

  <div class="hint__body">
    
  <p>
    Osoitteessa <a href="https://examples.javacodegeeks.com/desktop-java/javafx/javafx-media-api/" target="_blank">https://examples.javacodegeeks.com/desktop-java/javafx/javafx-media-api/</a> on opas mediasoittimen luomiseen. Jos äänten soittaminen ja käsittely ohjelmallisesti kiinnostaa, oppaaseen kannattaa tutustua.
  </p>
  

  </div>
</div>


<h1 class="material-heading">
    Laajempi sovellus: Asteroids

</h1>

<p>
  <a href="https://en.wikipedia.org/wiki/Asteroids_(video_game)" target="_blank">Asteroids</a> on <a href="https://en.wikipedia.org/wiki/Atari,_Inc." target="_blank">Atari</a>n kehittämä ja vuonna 1979 julkaisema tietokonepeliklassikko. Pelissä pelaaja ohjaa kolmionmuotoista avaruusalusta, ja pelin tavoitteena on tuhota asteroideja niitä ampuen. 
</p>

<p>
  Seuraavaksi tehdään laajempi esimerkki, missä toteutetaan osa Asteroids-pelistä. Peli on myös kurssin tehtävänä -- tee peli esimerkkiä seuraten annettuun tehtäväpohjaan (esimerkin lopussa).
</p>

<p>
  Peli koostetaan useammassa osassa, jotka ovat seuraavat:
</p>

<ul>
  <li>
    Peliruudun luominen
  </li>
  <li>
    Aluksen luominen
  </li>
  <li>
    Aluksen kääntäminen
  </li>
  <li>
    Aluksen liikuttaminen
  </li>
  <li>
    Asteroidin luominen
  </li>
  <li>
    Aluksen ja asteroidin törmääminen
  </li>
  <li>
    Useampi asteroidi
  </li>
  <li>
    Ruudussa pysyminen
  </li>
  <li>
    Ammukset
  </li>
  <li>
    Pisteiden lisääminen
  </li>
  <li>
    Lisää asteroideja
  </li>
</ul>


<h2 class="material-heading">
    Peliruudun luominen

</h2>

<p>
  Rakennetaan ohjelma niin, että ohjelman ruutu voi sisältää vapaavalintaisen määrän elementtejä, joiden sijaintiin käytettävä asettelu ei ota kantaa. Tähän sopii hyvin luokka <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Pane.html" target="_blank">Pane</a>. Luokka Pane sisältää edellisestä <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html" target="_blank">ObservableList</a>-tyyppisen listan lapsielementtejä. Listaan pääsee käsiksi Pane-luokan metodin <code>getChildren</code>-kautta.
</p>

<p>
  Alla olevassa esimerkissä on ohjelma, joka luo 300 pikseliä leveän ja 200 pikseliä korkean ruudun. Ruudussa on kohdassa 30, 50 ympyrä, jonka säde on 10 pikseliä. Tietokoneohjelmissa koordinaatiston origo on tyypillisesti ikkunan vasemmassa yläkulmassa. Lisäksi y-koordinaatin arvo kasvaa alaspäin mennessä.
</p>

<pre class="sh_java code-highlight"><code>import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;

public class PaneEsimerkki extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        Pane ruutu = new Pane();
        ruutu.setPrefSize(300, 200);
        ruutu.getChildren().add(new Circle(30, 50, 10));
  
        Scene scene = new Scene(ruutu);
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>


<img src="../img/material/pane-circle-4b00bee3.png" alt="Ympyrä ikkunassa."/>

<p>&nbsp;</p>

<p>
  Kutsutaan ohjelmaamme AsteroidsSovellukseksi. AsteroidsSovellus mukailee yllä olevaa esimerkkiä. Sovelluksessa ei aseteta ruutuun ympyrää, mutta sovellukselle on asetettu otsikko. Ikkunan leveys on 600 pikseliä ja korkeus 400 pikseliä.
</p>

<pre class="sh_java code-highlight"><code>import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

public class AsteroidsSovellus extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        Pane ruutu = new Pane();
        ruutu.setPrefSize(600, 400);
  
        Scene scene = new Scene(ruutu);
        stage.setTitle("Asteroids!");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>


<h2 class="material-heading">
    Aluksen luominen

</h2>

<p>
  Luodaan ohjelmaan seuraavaksi alus. Asteroidsissa alus on kolmio. Kolmion esittäminen onnistuu monikulmiota kuvaavan <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Polygon.html" target="_blank">Polygon</a>-luokan avulla. Monikulmion kulmat asetetaan Polygon-oliolle joko konstruktorin parametrina tai Polygon-luokan sisältämään listaan. Listaan pääsee käsiksi metodilla <code>getPoints</code>.
</p>

<p>
  Alla olevassa esimerkissä ruutuun on lisätty 100 pikseliä leveä ja 50 pikseliä korkea suunnikas, joka on luotu Polygon-luokan avulla.
</p>

<pre class="sh_java code-highlight"><code>@Override
public void start(Stage stage) throws Exception {
    Pane ruutu = new Pane();
    ruutu.setPrefSize(300, 200);

    Polygon suunnikas = new Polygon(0, 0, 100, 0, 100, 50, 0, 50);
    ruutu.getChildren().add(suunnikas);
  
    Scene scene = new Scene(ruutu);
    stage.setScene(scene);
    stage.show();
}
</code></pre>

<img src="../img/material/pane-suunnikas-f6601bc1.png" alt="Suunnikas ikkunassa."/>

<p>&nbsp;</p>

<p>
  Polygon-olion siirtäminen sopivampaan paikkaan onnistuu sen tarjoamien <code>setTranslateX</code> ja <code>setTranslateY</code>-metodien avulla. Alla olevassa esimerkissä luodaan edellistä esimerkkiä vastaava suunnikas, mutta nyt suunnikasta on siirretty 100 pikseliä oikealle ja 20 pikseliä alas.
</p>

<pre class="sh_java code-highlight"><code>@Override
public void start(Stage stage) throws Exception {
    Pane ruutu = new Pane();
    ruutu.setPrefSize(300, 200);

    Polygon suunnikas = new Polygon(0, 0, 100, 0, 100, 50, 0, 50);
    suunnikas.setTranslateX(100);
    suunnikas.setTranslateY(20);

    ruutu.getChildren().add(suunnikas);
  
    Scene scene = new Scene(ruutu);
    stage.setScene(scene);
    stage.show();
}
</code></pre>

<img src="../img/material/pane-suunnikas-siirretty-dbf4823f.png" alt="Suunnikas ikkunassa. Suunnikasta on siirretty 100 pikseliä oikealle ja 20 pikseliä alas."/>

<p>&nbsp;</p>

<p>
  Luodaan alusta kuvaava kolmio ja lisätään se aiempaan AsteroidsSovellukseemme. Siirretään hahmo ruudun keskelle -- koska ruudun leveys on 600 pikseliä ja ruudun korkeus on 400 pikseliä, hahmoa siirretään 300 pikseliä oikealla ja 200 pikseliä alas.
</p>

<pre class="sh_java code-highlight"><code>import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Polygon;
import javafx.stage.Stage;

public class AsteroidsSovellus extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        Pane ruutu = new Pane();
        ruutu.setPrefSize(600, 400);

        Polygon alus = new Polygon(-5, -5, 10, 0, -5, 5);
        alus.setTranslateX(300);
        alus.setTranslateY(200);
  
        Scene scene = new Scene(alus);
        stage.setTitle("Asteroids!");
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>


<h2 class="material-heading">
    Aluksen kääntäminen

</h2>

<p>
  Luokat kuten Polygon ja Circle perivät JavaFx:n <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/Node.html" target="_blank">Node</a>-luokan. Node-luokalla on valmiina muuttuja <code>rotate</code>, joka kuvaa esineen käännöstä asteina. Minkä tahansa Node-luokan perivän olion kääntäminen on siis melko suoraviivaista -- tarvitsee vain käyttää valmista metodia <code>setRotate</code>. Metodille annetaan parametrina käännöksen asteluku. 
</p>

<p>
  Alla olevassa esimerkissä edellä nähtyä esimerkkiä on muunnettu siten, että alusta on käännetty 30 astetta.
</p>

<pre class="sh_java code-highlight"><code>@Override
public void start(Stage stage) throws Exception {
    Pane ruutu = new Pane();
    ruutu.setPrefSize(600, 400);

    Polygon alus = new Polygon(-5, -5, 10, 0, -5, 5);
    alus.setTranslateX(300);
    alus.setTranslateY(200);
    alus.setRotate(30);

    ruutu.getChildren().add(alus);
  
    Scene scene = new Scene(ruutu);
    stage.setScene(scene);
    stage.show();
}
</code></pre>

<p>
  Todellisuudessa emme kuitenkaan halua tilannetta, missä alus kääntyy vain kerran, vaan tilanteen, missä alusta voi ohjata pelin käynnissäollessa. Tarvitsemme siis tapahtumankuuntelijan, joka kuuntelee näppäimistöä ja kääntää alusta näppäimistön painalluksen yhteydessä.
</p>


<h3 class="material-heading">
    Näppäimistön kuuntelija, osa 1

</h3>

<p>
  Ikkunan sisältöä kuvaava <code>Scene</code>-olio tarjoaa metodin <code>setOnKeyPressed</code>, jolle voidaan antaa parametrina tapahtumia käsittelevä olio. Luodaan tapahtumankäsittelijä, joka reagoi näppäimistöön. Näppäimistötapahtumiin liittyy enumeroitu muuttuja <code>KeyCode</code>, joka kertoo painetun napin. Olemme kiinnostuneita napeista vasen (LEFT) ja oikea (RIGHT).
</p>

<p>
  Tehdään ensin testiversio, missä aluksen käännös on yksinkertainen. Jos käyttäjä painaa nuolta vasemmalle, asteeksi asetetaan -30. Jos taas käyttäjä painaa nuolta oikealle, asteeksi asetetaan 30.
</p>

<pre class="sh_java code-highlight"><code>scene.setOnKeyPressed(event -&gt; {
    if (event.getCode() == KeyCode.LEFT) {
        alus.setRotate(-30);
    }

    if (event.getCode() == KeyCode.RIGHT) {
        alus.setRotate(30);
    }
});
</code></pre>

<p>
  Jos aluksen sijaan käytössä olisi suunnikas, ohjelman toiminta näyttäisi seuraavanlaiselta.
</p>

<img src="../img/material/pane-polygon-move-0e37bef4.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>

<p>
  Käännöksen saa tasaiseksi hyödyntämällä tietoa olemassaolevasta käännöksestä. Alla olevassa esimerkissä alus kääntyy viisi astetta kerrallaan.
</p>

<pre class="sh_java code-highlight"><code>scene.setOnKeyPressed(event -&gt; {
    if (event.getCode() == KeyCode.LEFT) {
        alus.setRotate(alus.getRotate() - 5);
    }

    if (event.getCode() == KeyCode.RIGHT) {
        alus.setRotate(alus.getRotate() + 5);
    }
});
</code></pre>

<p>
  Alla kuvattuna vastaava esimerkki, missä aluksen sijaan käännetään suunnikasta.
</p>

<img src="../img/material/pane-polygon-move-rotate-bfba93d1.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>

<h3 class="material-heading">
    Näppäimistön kuuntelija, osa 2

</h3>

<p>
  Edellä kuvattu lähestymistapa mahdollistaa "ihan ok"-tyyppisen kääntämisen. Lähestymistavassa on samalla ongelma -- liike ei ole sulavaa. Kun nappia painaa, alus kääntyy, pitää pienen tauon, ja jatkaa vasta tämän jälkeen kääntymistä.
</p>

<p>
  Tämä liittyy siihen, miten ohjelmat oletuksena käsittelevät näppäinten painalluksen. Jos ohjelma käsittelisi näppäimen painalluksen useana tapahtumana heti kun näppäintä painetaan, muuttuisi esimerkiksi tekstin kirjoittaminen paljon hankalammaksi, sillä hieman pidemmät painallukset tuottaisivat heti useampia merkkejä.
</p>

<p>
  Muutetaan näppäinten käsittelyä siten, että pidämme kirjaa pohjassa olevista napeista. Tämä onnistuu (esimerkiksi) hajautustaulun avulla. Hajautustaulu sisältää avaimena KeyCode-olion, eli nappia kuvaavan olion, ja arvona Boolean-tyyppisen muuttujan. Jos tiettyyn nappiin liittyvän boolean-muuttujan arvo on <code>true</code>, nappi on pohjassa, muulloin nappi ei ole pohjassa.
</p>

<p>
  Nyt huomioidaan myös napin nostaminen, eli <code>onKeyReleased</code>-tapahtuma.
</p>

<pre class="sh_java code-highlight"><code>Map&lt;KeyCode, Boolean&gt; painetutNapit = new HashMap&lt;&gt;();

scene.setOnKeyPressed(event -&gt; {
    painetutNapit.put(event.getCode(), Boolean.TRUE);
});

scene.setOnKeyReleased(event -&gt; {
    painetutNapit.put(event.getCode(), Boolean.FALSE);
});
</code></pre>

<p>
  Mutta! Eihän tuolla mikään nyt käännä alusta.
</p>

<p>
  Ei niin. Tarvitsemme vielä kääntämistoiminnallisuuden. Otetaan käyttöön animaatioiden luomiseen tarkoitettu AnimationTimer-luokka, ja annetaan sen vastuulle aluksen kääntäminen mikäli vasen tai oikea nappi on pohjassa.
</p>

<pre class="sh_java code-highlight"><code>Map&lt;KeyCode, Boolean&gt; painetutNapit = new HashMap&lt;&gt;();

scene.setOnKeyPressed(event -&gt; {
    painetutNapit.put(event.getCode(), Boolean.TRUE);
});

scene.setOnKeyReleased(event -&gt; {
    painetutNapit.put(event.getCode(), Boolean.FALSE);
});
  
new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
            alus.setRotate(alus.getRotate() - 5);
        }
  
        if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
            alus.setRotate(alus.getRotate() + 5);
        }
    }
}.start();
</code></pre>

<p>
  AnimationTimer-luokan maetodia <code>handle</code> kutsutaan noin 60 kertaa sekunnissa. Nyt kääntyminen on paljon sulavampaa (tosin, sitä ei alla olevasta gif-kuvasta taida huomata...).
</p>


<img src="../img/material/pane-polygon-move-rotate-better-85f198e6.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>


<h2 class="material-heading">
    Aluksen liikuttaminen

</h2>

<p>
  Alustamme pystyy nyt kääntämään. Lisätään seuraavaksi mahdollisuus liikkumiseen. Alus voi liikkua mihin tahansa ilmansuuntaan, eli liikkeen kuvaamiseen tarvitaan sekä x- että y-koordinaatin arvo. Konkreettinen liikkuminen tapahtuu muuntamalla alusta kuvaavan polygonin sijaintia ohjelman edetessä.
</p>


<h3 class="material-heading">
    Ensimmäinen yritys

</h3>

<p>
  Hyödynnetään Javan valmista <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/geometry/Point2D.html" target="_blank">Point2D</a>-luokkaa liikkeen kuvaamiseen -- luokalla on sekä x- että y-koordinaatti.
</p>

<p>
  Ensimmäinen testiversio on liike-muuttujan luominen sekä sen lisääminen AnimationTimer-luokan handle-metodiin.
</p>

<pre class="sh_java code-highlight"><code>Point2D liike = new Point2D(1, 0);
</code></pre>

<pre class="sh_java code-highlight"><code>new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
            alus.setRotate(alus.getRotate() - 5);
        }
  
        if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
            alus.setRotate(alus.getRotate() + 5);
        }
  
        alus.setTranslateX(alus.getTranslateX() + liike.getX());
    }
}.start();
</code></pre>

<p>
  Huraa! Alus liikkuu (ja sitä voi kääntää). Se tosin katoaa aika nopeasti..
</p>

<img src="../img/material/pane-alus-liikkuu-e552f96c.gif" alt="Suunnikasta voi kääntää vasemmalle tai oikealle."/>

<p>&nbsp;</p>

<p>
  Valitsemamme Point2D luokka muistuttaa hieman String-luokkaa siinä, että se on <em>immutaabeli</em>. Emme voi muuttaa olemassaolevan pisteen arvoja, vaan pisteen metodien kutsuminen palauttaa aina uuden arvon. Tämä on hieman ongelmallista, sillä olioiden arvoja ei saa asettaa uudestaan metodien sisällä -- emme siis voi tehdä esimerkiksi seuraavasti.
</p>

<pre class="sh_java code-highlight"><code>new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        // .. ei toimi ..
        if(painetutNapit.getOrDefault(KeyCode.UP, false)) {
            liike = liike.add(new Point2D(1, 1));
        }
        // ..
    }
}.start();
</code></pre>

<p>
  Metodikutsut ovat kuitenkin sallittuja. Taitaa olla aika refaktoroinnille, eli ohjelman rakenteen selkeyttämiselle..
</p>


<h3 class="material-heading">
    Ohjelman refaktorointi

</h3>

<p>
  Luodaan luokka Alus, joka sisältää Polygon-olion sekä Point2D-olion. Polygon-olio kuvaa alusta, ja Point2D-olio aluksen liikettä. Alus saa konstruktorin parametrina aluksen x- ja y-koordinaatit, jonka lisäksi alusta voi kääntää vasemmalle ja oikealle. 
</p>

<pre class="sh_java code-highlight"><code>import javafx.geometry.Point2D;
import javafx.scene.shape.Polygon;

public class Alus {

    private Polygon hahmo;
    private Point2D liike;

    public Alus(int x, int y) {
        this.hahmo = new Polygon(-5, -5, 10, 0, -5, 5);
        this.hahmo.setTranslateX(x);
        this.hahmo.setTranslateY(y);

        this.liike = new Point2D(0, 0);
    }

    public Polygon getHahmo() {
        return hahmo;
    }

    public void kaannaVasemmalle() {
        this.hahmo.setRotate(this.hahmo.getRotate() - 5);
    }

    public void kaannaOikealle() {
        this.hahmo.setRotate(this.hahmo.getRotate() - 5);
    }

    public void liikuta() {
        this.hahmo.setTranslateX(this.hahmo.getTranslateX() + this.liike.getX());
        this.hahmo.setTranslateY(this.hahmo.getTranslateY() + this.liike.getY());
    }
}
</code></pre>

<p>
  Refaktoroinnin johdosta sovellusta tulee muuttaa muutamasta kohtaa. Liikettä kuvaavan pisteen sijaan ja alusta kuvaavan monikulmion sijaan luodaan Alus. Tämän lisäksi Pane-oliolle annetaan alukseen liittyvä Polygon-olio, mutta ei itse alus-oliota.
</p>

<pre class="sh_java code-highlight"><code>Alus alus = new Alus(150, 100);

ruutu.getChildren().add(alus.getHahmo());
</code></pre>

<p>
  Myös AnimationTimer-olion metodia tulee päivittää siten, että metodissa hyödynnetään aluksen metodeja.
</p>

<pre class="sh_java code-highlight"><code>new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
            alus.kaannaVasemmalle();
        }
  
        if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
            alus.kaannaOikealle();
        }
  
        alus.liiku();
    }
}.start();
</code></pre>


<h3 class="material-heading">
    Toinen yritys

</h3>

<p>
  Alus liikkuu, mutta aluksen liikettä ei voi vielä muuttaa. Lisätään alukselle kiihdytystoiminnallisuus. Kiihdytyksen tulee toimia niin, että aluksen nopeus kiihtyy aluksen osoittamaan suuntaan. Saamme kiihdytyksen monikulmion asteesta, jonka saa selville metodilla <code>getRotate()</code>. Olemme käyttäneet tätä jo paljon alusta kääntäessä.
</p>

<p>
  Kiihdytyksen suunta saadaan selville sini- ja kosinifunktion avulla. Nämä löytyvät Javan valmiista <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html" target="_blank">Math</a>-luokasta. Metodit saavat parametrina asteen radiaaneina, joten joudumme hyödyntämään myös Math-luokan asteiden radiaaneiksi muuttavaa metodia.
</p>

<pre class="sh_java code-highlight"><code>double muutosX = Math.cos(Math.toRadians(<em>kulmaAsteina</em>));
double muutosY = Math.sin(Math.toRadians(<em>kulmaAsteina</em>));
</code></pre>

<p>
  Luokan Alus kiihdyta-metodin ensimmäinen versio on seuraavanlainen.
</p>

<pre class="sh_java code-highlight"><code>public void kiihdyta() {
    double muutosX = Math.cos(Math.toRadians(this.hahmo.getRotate()));
    double muutosY = Math.sin(Math.toRadians(this.hahmo.getRotate()));

    this.liike = this.liike.add(muutosX, muutosY);
}
</code></pre>

<p>
  Lisätään sovellukseen vielä kiihdytystoiminnallisuus. Kiihdytysmetodia kutsutaan kun käyttäjä painaa ylös-nappia. 
</p>

<pre class="sh_java code-highlight"><code>new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        if(painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
            alus.kaannaVasemmalle();
        }
  
        if(painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
            alus.kaannaOikealle();
        }
  
        if(painetutNapit.getOrDefault(KeyCode.UP, false)) {
            alus.kiihdyta();
        }

        alus.liiku();
    }
}.start();
</code></pre>

<img src="../img/material/pane-alus-kiihtyy-2d0128dc.gif" alt="Alus kiihtyy."/>

<p>&nbsp;</p>

<p>
  Kuten huomaamme, alus kiihtyy. Kiihtyvyys on tosin aika kova, joten sitä on hyvä korjata hieman. Muokataan aluksen kiihdyta-metodia siten, että muutos on vain 5% edellisestä. 
</p>

<pre class="sh_java code-highlight"><code>public void kiihdyta() {
    double muutosX = Math.cos(Math.toRadians(this.hahmo.getRotate()));
    double muutosY = Math.sin(Math.toRadians(this.hahmo.getRotate()));

    muutosX *= 0.05;
    muutosY *= 0.05;
  
    this.liike = this.liike.add(muutosX, muutosY);
}
</code></pre>

<p>
  Nyt aluksen ohjaus on jotenkuten mahdollista.
</p>

<img src="../img/material/alus-kiihtyy-fiksummin-be6d3696.gif" alt="Alus kiihtyy siten, että sitä pystyy kontrolloimaan."/>

<p>&nbsp;</p>


<h2 class="material-heading">
    Asteroidin luominen

</h2>

<p>
  Luodaan seuraavaksi asteroidi. Asteroidilla on muoto, sijainti ja liike.
</p>

<p>
  Hmm..
</p>

<p>
  Oikeastaan lähes täysin samat asiat kuin mitä aluksella on -- vain muoto on erilainen. Tässä kohtaa on hyvä hetki <em>yleistämiselle</em>. Luodaan <em>abstrakti luokka</em> Hahmo, joka saa parametrina muodon ja sijainnin. Huomaat, että toiminnallisuus on lähes täysin kopioitu luokasta <code>Alus</code>.
</p>

<pre class="sh_java code-highlight"><code>import javafx.geometry.Point2D;
import javafx.scene.shape.Polygon;

public abstract class Hahmo {

    private Polygon hahmo;
    private Point2D liike;

    public Hahmo(Polygon monikulmio, int x, int y) {
        this.hahmo = monikulmio;
        this.hahmo.setTranslateX(x);
        this.hahmo.setTranslateY(y);

        this.liike = new Point2D(0, 0);
    }

    public Polygon getHahmo() {
        return hahmo;
    }

    public void kaannaVasemmalle() {
        this.hahmo.setRotate(this.hahmo.getRotate() - 5);
    }

    public void kaannaOikealle() {
        this.hahmo.setRotate(this.hahmo.getRotate() + 5);
    }

    public void liiku() {
        this.hahmo.setTranslateX(this.hahmo.getTranslateX() + this.liike.getX());
        this.hahmo.setTranslateY(this.hahmo.getTranslateY() + this.liike.getY());
    }

    public void kiihdyta() {
        double muutosX = Math.cos(Math.toRadians(this.hahmo.getRotate()));
        double muutosY = Math.sin(Math.toRadians(this.hahmo.getRotate()));

        muutosX *= 0.05;
        muutosY *= 0.05;

        this.liike = this.liike.add(muutosX, muutosY);
    }
}
</code></pre>

<p>
  Muokataan luokkaa Alus siten, että se perii luokan Hahmo.
</p>

<pre class="sh_java code-highlight"><code>import javafx.scene.shape.Polygon;

public class Alus extends Hahmo {

    public Alus(int x, int y) {
        super(new Polygon(-5, -5, 10, 0, -5, 5), x, y);
    }
}
</code></pre>

<p>
  Aika suoraviivaista.
</p>

<p>
  Lisätään seuraavaksi luokka Asteroidi. Tehdään ensimmäisestä toteutuksesta suorakulmio ja palataan asteroidin muotoon myöhemmin.
</p>

<pre class="sh_java code-highlight"><code>import javafx.scene.shape.Polygon;

public class Asteroidi extends Hahmo {

    public Asteroidi(int x, int y) {
        super(new Polygon(20, -20, 20, 20, -20, 20, -20, -20), x, y);
    }
}
</code></pre>

<p>
  Testataan vielä, että asteroidin voi lisätä sovellukseen.
</p>

<pre class="sh_java code-highlight"><code>Pane ruutu = new Pane();
// koon asetus .. 

Alus alus = new Alus(150, 100);
Asteroidi asteroidi = new Asteroidi(50, 50);

ruutu.getChildren().add(alus.getHahmo());
ruutu.getChildren().add(asteroidi.getHahmo());
  
asteroidi.kaannaOikealle();
asteroidi.kaannaOikealle();
asteroidi.kiihdyta();
asteroidi.kiihdyta();
</code></pre>

<p>
  Jotta asteroidi liikkuisi, tulee siihen liittyvää liiku-metodia kutsua animaatiossa.
</p>

<pre class="sh_java code-highlight"><code>new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        if (painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
            alus.kaannaVasemmalle();
        }

        if (painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
            alus.kaannaOikealle();
        }

        if (painetutNapit.getOrDefault(KeyCode.UP, false)) {
            alus.kiihdyta();
        }

        alus.liiku();
        asteroidi.liiku();
    }
}.start();
</code></pre>

<p>
  Sovelluksessamme on nyt sekä alus että asteroidi.
</p>

<img src="../img/material/asteroidi-huti-cfb82d8b.gif" alt="Sovelluksessa sekä alus että yksi asteroidi."/>

<p>&nbsp;</p>


<h2 class="material-heading">
    Aluksen ja asteroidin törmääminen

</h2>

<p>
  Toteutetaan seuraavaksi aluksen ja asteroidin törmäämisen tarkistaminen. Jos alus törmää asterodiin, kutsutaan AnimationTimer-olion metodia <code>stop</code>, joka lopettaa animaation.
</p>

<p>
  Sekä alus että asteroidi ovat hahmoja. Lisätään luokalle <code>Hahmo</code> metodi, jota käytetään törmäyksen tarkastamiseen. Metodin ensimmäinen versio on sellainen, että hahmo ei koskaan törmää toiseen hahmoon.
</p>

<pre class="sh_java code-highlight"><code>public boolean tormaa(Hahmo toinen) {
    return false;
}
</code></pre>

<p>
  Luokalla <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Shape.html" target="_blank">Shape</a>, jonka Polygon <em>myös</em> perii, on törmäyksen tarkastamista varten varsin näppärä metodi. Metodi <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Shape.html#intersect-javafx.scene.shape.Shape-javafx.scene.shape.Shape-" target="_blank">public static Shape intersect(Shape shape1, Shape shape2)</a> palauttaa kahden Shape-tyyppisen olion leikkausalueen.
</p>

<p>
  Jos alue on tyhjä, törmäystä ei ole tapahtunut. Muokataan törmäysten tarkistamista siten, että se hyödyntää edellä mainittua metodia. 
</p>

<pre class="sh_java code-highlight"><code>public boolean tormaa(Hahmo toinen) {
    Shape tormaysalue = Shape.intersect(this.hahmo, toinen.getHahmo());
    return tormaysalue.getBoundsInLocal().getWidth() != -1;
}
</code></pre>

<p>
  Lisätään ohjelmaan vielä toiminnallisuus, joka lopettaa sovelluksen törmäyksen yhteydessä.
</p>

<pre class="sh_java code-highlight"><code>new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        if (painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
            alus.kaannaVasemmalle();
        }

        if (painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
            alus.kaannaOikealle();
        }

        if (painetutNapit.getOrDefault(KeyCode.UP, false)) {
            alus.kiihdyta();
        }

        alus.liiku();
        asteroidi.liiku();

        if (alus.tormaa(asteroidi)) {
            stop();
        }
    }
}.start();
</code></pre>

<p>
  Nyt sovellus pysähtyy aluksen ja asteroidin törmätessä.
</p>

<img src="../img/material/asteroids-tormays-e7e2424d.gif" alt="Sovellus pysähtyy mikäli alus ja asteroidi törmäävät."/>

<p>&nbsp;</p>



<h2 class="material-heading">
    Useampi asteroidi

</h2>

<p>
  Muokataan sovellusta seuraavaksi siten, että sovelluksessa on useampia asteroideja. Asteroidit on hyvä esittää listana. Alla olevassa esimerkissä luodaan ensin alus, jonka jälkeen sovellukseen lisätään viisi asteroidia.
</p>

<pre class="sh_java code-highlight"><code>Alus alus = new Alus(150, 100);
List&lt;Asteroidi&gt; asteroidit = new ArrayList&lt;&gt;();
for (int i = 0; i &lt; 5; i++) {
    Random rnd = new Random();
    Asteroidi asteroidi = new Asteroidi(rnd.nextInt(100), rnd.nextInt(100));
    asteroidit.add(asteroidi);
}

ruutu.getChildren().add(alus.getHahmo());
asteroidit.forEach(asteroidi -&gt; ruutu.getChildren().add(asteroidi.getHahmo()));
</code></pre>

<p>
  Muokataan vielä asteroidien piirtämistä ja törmäystoiminnallisuutta siten, että yksittäisen asteroidin sijaan käydään lista läpi.
</p>

<pre class="sh_java code-highlight"><code>new AnimationTimer() {

    @Override
    public void handle(long nykyhetki) {
        if (painetutNapit.getOrDefault(KeyCode.LEFT, false)) {
            alus.kaannaVasemmalle();
        }

        if (painetutNapit.getOrDefault(KeyCode.RIGHT, false)) {
            alus.kaannaOikealle();
        }

        if (painetutNapit.getOrDefault(KeyCode.UP, false)) {
            alus.kiihdyta();
        }

        alus.liiku();
        asteroidit.forEach(asteroidi -&gt; asteroidi.liiku());

        asteroidit.forEach(asteroidi -&gt; {
            if (alus.tormaa(asteroidi)) {
                stop();
            }
        });

    }
}.start();
</code></pre>

<p>
  Ohjelman käynnistyessä siinä on nyt useampia asteroideja.
</p>

<img src="../img/material/asteroids-monta-asteroidia-c6b54e68.png" alt="Monta asteroidia."/>

<p>&nbsp;</p>

<p>
  Tällä hetkellä jokainen asteroidi näyttää samalta ja liikkuu samalla tavalla. Olisi hienoa, jos asteroideissa olisi vähän vaihtelua. Muokataan Asteroidi-luokkaa siten, että luokalla on erillinen metodi asteroidin rakenteen arpomiseen. Sovitaan, että asteroidit ovat aina viisikulmaisia, ja että niiden perusmuoto on viisikulmio. Luodaan vaihtelua asteroideihin muokkaamalla niiden kulmien sijainteja hieman.
</p>

<p>
  Viisikulmion kulmien laskemiseen saa apua osoitteesta <a href="http://mathworld.wolfram.com/Pentagon.html" target=_blank">http://mathworld.wolfram.com/Pentagon.html</a>. Alla on sovellettu linkin takana olevaa kaavaa, jonka lisäksi monikulmion koko on vaihteleva sekä monikulmion kulmien sijainnit voivat vaihdella hieman.
</p>

<pre class="sh_java code-highlight"><code>import java.util.Random;
import javafx.scene.shape.Polygon;

public class MonikulmioTehdas {

    public Polygon luoMonikulmio() {
        Random rnd = new Random();

        double koko = 10 + rnd.nextInt(10);

        Polygon monikulmio = new Polygon();
        double c1 = Math.cos(Math.PI * 2 / 5);
        double c2 = Math.cos(Math.PI / 5);
        double s1 = Math.sin(Math.PI * 2 / 5);
        double s2 = Math.sin(Math.PI * 4 / 5);

        monikulmio.getPoints().addAll(
            koko, 0.0,
            koko * c1, -1 * koko * s1,
            -1 * koko * c2, -1 * koko * s2,
            -1 * koko * c2, koko * s2,
            koko * c1, koko * s1);

        for (int i = 0; i &lt; monikulmio.getPoints().size(); i++) {
            int muutos = rnd.nextInt(5) - 2;
            monikulmio.getPoints().set(i, monikulmio.getPoints().get(i) + muutos);
        }

        return monikulmio;
    }
}
</code></pre>

<p>
  Muokataan luokkaa Asteroidi siten, että se hyödyntää yllä kuvattua monikulmioiden luomiseen tarkoitettua luokkaa. 
</p>

<pre class="sh_java code-highlight"><code>public class Asteroidi extends Hahmo {

    public Asteroidi(int x, int y) {
        super(new MonikulmioTehdas().luoMonikulmio(), x, y);
    }

}
</code></pre>

<p>
  Nyt asteroidit ovat monipuolisempia. 
</p>

<img src="../img/material/asteroids-satunnaiset-monikulmiot-57c8e80f.png" alt="Asteroideissa on vaihtelua."/>

<p>&nbsp;</p>

<p>
  Lisätään asteroideille vielä liike ja suunta. Liike ja suunta on osittain määriteltynä luokassa Hahmo, mutta haluamme toimintaan hieman satunnaisuutta. Kun asteroidi luodaan, sen suunnan tulee olla satunnainen luku välillä [0, 360[. Tämän lisäksi asteroidi liikkuu hieman -- liike määritetään satunnaisena määränä kiihdytyskutsuja hahmon luonnin yhteydessä. Lopuksi asteroidilla on myös pieni pyörimisliike. Aina kun asteroidi liikkuu, se myös pyörii hieman.
</p>

<pre class="sh_java code-highlight"><code>import java.util.Random;

public class Asteroidi extends Hahmo {

    private double pyorimisliike;

    public Asteroidi(int x, int y) {
        super(new MonikulmioTehdas().luoMonikulmio(), x, y);

        Random rnd = new Random();

        super.getHahmo().setRotate(rnd.nextInt(360));

        int kiihdytystenMaara = 1 + rnd.nextInt(10);
        for (int i = 0; i &lt; kiihdytystenMaara; i++) {
            kiihdyta();
        }

        this.pyorimisliike = 0.5 - rnd.nextDouble();
    }

    @Override
    public void liiku() {
        super.liiku();
        super.getHahmo().setRotate(super.getHahmo().getRotate() + pyorimisliike);
    }
}
</code></pre>

<p>
  Yllä olevassa esimerkissä hyödynnetään perintää myös metodissa <code>liiku</code>. Kun Asteroidin liiku-metodia kutsutaan, metodi kutsuu ensin yläluokassa Hahmo määriteltyä metodia liiku. Tämän jälkeen hahmoa käännetään pyörimisliikkeen verran. Lopputuloksena asteroidilla on pieni pyörimisliike.
</p>


<img src="../img/material/asteroidit-liikkuu-1bb37e30.gif" />

<p>&nbsp;</p>


<h2 class="material-heading">
    Ruudussa pysyminen

</h2>

<p>
  Sovellus on hieman tylsä, sillä asteroidit ja alus voivat siirtyä pois ruudusta. Muokataan sovellusta siten, että asteroidit ja alus pysyvät jatkuvasti ruudussa. Tämä onnistuu muokkaamalla niiden liikkumista siten, että oikealta laidalta poistuttaessa hahmo tulee takaisin vasemmalta laidalta ja toisinpäin. Vastaava toiminnallisuus tarvitaan myös yläkautta ja alakautta poistumiselle. 
</p>

<p>
  Määritellään AsteroidsSovellukselle vakioarvoiset muuttujat leveys ja korkeus. Luokille voidaan määritellä luokkakohtaisia arvoja avainsanan <code>static</code> avulla. Alla määritellään muuttujat <code>LEVEYS</code> ja <code>KORKEUS</code>, joihin voidaan viitata muualta ohjelmasta.
</p>


<pre class="sh_java code-highlight"><code>public class AsteroidsSovellus extends Application {

    public static int LEVEYS = 300;
    public static int KORKEUS = 200;

    @Override
    public void start(Stage stage) throws Exception {
        Pane ruutu = new Pane();
        ruutu.setPrefSize(LEVEYS, KORKEUS);

        Alus alus = new Alus(LEVEYS / 2, KORKEUS / 2);
        List&lt;Asteroidi&gt; asteroidit = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            Random rnd = new Random();
            Asteroidi asteroidi = new Asteroidi(rnd.nextInt(LEVEYS / 3), rnd.nextInt(KORKEUS));
            asteroidit.add(asteroidi);
        }

        ruutu.getChildren().add(alus.getHahmo());
        asteroidit.forEach(asteroidi -&gt; ruutu.getChildren().add(asteroidi.getHahmo()));

// ...
</code></pre>

<p>
  Muuttujat, jotka on määritelty avainsanalla <code>static</code>, eivät liity luokasta tehtäviin olioihin. Jos <code>static</code>-muuttujalla on määre <code>public</code> -- kuten yllä -- voi muuttujaan viitata myös muista luokista. Muokataan luokan Hahmo liiku-metodia siten, että se hyödyntää AsteroidsSovelluksen <em>staattisia muuttujia</em> LEVEYS ja KORKEUS. Alla oleva liiku-metodi tarkastaa, että hahmo on jatkuvasti näkyvillä. 
</p>

<pre class="sh_java code-highlight"><code>public void liiku() {
    this.hahmo.setTranslateX(this.hahmo.getTranslateX() + this.liike.getX());
    this.hahmo.setTranslateY(this.hahmo.getTranslateY() + this.liike.getY());

    if (this.hahmo.getTranslateX() &lt; 0) {
        this.hahmo.setTranslateX(this.hahmo.getTranslateX() + AsteroidsSovellus.LEVEYS);
    }

    if (this.hahmo.getTranslateX() &gt; AsteroidsSovellus.LEVEYS) {
        this.hahmo.setTranslateX(this.hahmo.getTranslateX() % AsteroidsSovellus.LEVEYS);
    }

    if (this.hahmo.getTranslateY() &lt; 0) {
        this.hahmo.setTranslateY(this.hahmo.getTranslateY() + AsteroidsSovellus.KORKEUS);
    }

    if (this.hahmo.getTranslateY() &gt; AsteroidsSovellus.KORKEUS) {
        this.hahmo.setTranslateY(this.hahmo.getTranslateY() % AsteroidsSovellus.KORKEUS);
    }
}
</code></pre>

<p>
  Nyt hahmot pysyvät ruudussa.
</p>

<img src="../img/material/asteroids-pysyy-ruudussa-a074bbf1.gif" />

<p>&nbsp;</p>

<p>
  Emme ole yllä kuvattuun versioon täysin tyytyväisiä, sillä hahmot saattavat "hypätä" ruudun laidalta toiselle. Hahmon kokoa ei huomioida yllä kuvatussa liikkumistoiminnossa, jolloin hahmon x- tai y-koordinaatti voi olla ulkona ruudusta, vaikka osa hahmosta olisi vielä näkyvissä. Tähän löytyy -- mahdollisesti -- ratkaisu Node-luokalta löytyvästä getBoundsInParent-metodista. Emme tarkastele tätä kuitenkaan sen enempää.
</p>


<h2 class="material-heading">
    Ammukset

</h2>

<p>
  Asteroids ilman ammuksia olisi pelkkää väistelyä. Lisätään asteroidsiin seuraavaksi ammukset. Ammuksilla on muoto, suunta ja liike. Voimme käyttää Hahmoa myös Ammusten luomiseen. Luodaan Ammus-luokan ensimmäinen versio, missä ammusta kuvataan neliön avulla.
</p>

<pre class="sh_java code-highlight"><code>import javafx.scene.shape.Polygon;

public class Ammus extends Hahmo {

    public Ammus(int x, int y) {
        super(new Polygon(2, -2, 2, 2, -2, 2, -2, -2), x, y);
    }

}
</code></pre>

<p>
  Toisin kuin hahmojen ja asteroidien tapauksessa, emme halua että pelin alkutilassa on ammuksia. Määritellään ammuksia varten lista, mutta jätetään se aluksi tyhjäksi.
</p>

<pre class="sh_java code-highlight"><code>List&lt;Ammus&gt; ammukset = new ArrayList&lt;&gt;();
</code></pre>

<p>
  Ammus luodaan kun käyttäjä painaa välilyöntiä. Ammuksen luomisen yhteydessä sen suunnaksi asetetaan aluksen suunta. Luodaan ampumisesta ensimmäinen versio.
</p>

<pre class="sh_java code-highlight"><code>if (painetutNapit.getOrDefault(KeyCode.SPACE, false)) {
    // ammutaan
    Ammus ammus = new Ammus((int) alus.getHahmo().getTranslateX(), (int) alus.getHahmo().getTranslateY());
    ammus.getHahmo().setRotate(alus.getHahmo().getRotate());
    ammukset.add(ammus);

    ruutu.getChildren().add(ammus.getHahmo());
}
</code></pre>

<p>
  Ensimmäisessä versiossa alus ampuu kun käyttäjä painaa välilyöntiä, mutta ammukset eivät liiku. Ammukset eivät myöskään törmää muihin hahmoihin.
</p>

<img src="../img/material/alus-ampuu-bc2d0361.gif" />

<p>&nbsp;</p>

<p>
  Haluamme, että ammuksen liikettä voidaan muokata. Tällä hetkellä Hahmon muuttuja <code>liike</code> on kuitenkin määritelty private-tyyppiseksi, eikä siihen ole pääsyä minkään metodin kautta. Lisätään luokalle <code>Hahmo</code> metodit <code>getLiike</code> ja <code>setLiike</code>.
</p>

<p>
  Tämän jälkeen ammuksen nopeuden asettaminen on suoraviivaista. Kiihdytetään ammuksen nopeutta hieman (jottei ammus jää koskaan paikalleen), normalisoidaan nopeus (käytännössä nopeutta käsitellään vektorina, jonka pituudeksi asetetaan 1), jonka jälkeen nopeutta kasvatetaan hieman. Tässä nopeus kerrotaan kolmella.
</p>

<pre class="sh_java code-highlight"><code>if (painetutNapit.getOrDefault(KeyCode.SPACE, false)) {
    // ammutaan
    Ammus ammus = new Ammus((int) alus.getHahmo().getTranslateX(), (int) alus.getHahmo().getTranslateY());
    ammus.getHahmo().setRotate(alus.getHahmo().getRotate());
    ammukset.add(ammus);
  
    ammus.kiihdyta();
    ammus.setLiike(ammus.getLiike().normalize().multiply(3));
  
    ruutu.getChildren().add(ammus.getHahmo());
}
</code></pre>

<p>
  Lisätään vielä ammusten liikkuminen muiden hahmojen liikkumisen yhteyteen.
</p>

<pre class="sh_java code-highlight"><code>alus.liiku();
asteroidit.forEach(asteroidi -&gt; asteroidi.liiku());
ammukset.forEach(ammus -&gt; ammus.liiku());
</code></pre>

<p>
  Nyt ammukset liikkuvat. Ne eivät kuitenkaan vielä törmää mihinkään, ja niitä on aika.. paljon. Rajataan ammusten määrää ensin hieman -- sovitaan, että ammuksia saa olla kerrallaan korkeintaan 3.
</p>

<pre class="sh_java code-highlight"><code>if (painetutNapit.getOrDefault(KeyCode.SPACE, false)
        && ammukset.size() &lt; 3) {
    // ammutaan
    Ammus ammus = new Ammus((int) alus.getHahmo().getTranslateX(), (int) alus.getHahmo().getTranslateY());
    ammus.getHahmo().setRotate(alus.getHahmo().getRotate());
    ammukset.add(ammus);

    ammus.kiihdyta();
    ammus.setLiike(ammus.getLiike().normalize().multiply(3));

    ruutu.getChildren().add(ammus.getHahmo());
}
</code></pre>

<p>
  Lisätään tämän jälkeen ammuksille törmäystoiminnallisuus. Ammukset voivat törmätä asteroideihin. Jos ammus törmää asteroidiin, asteroidi poistetaan sekä piirrettävistä asteroideista että asteroidilistasta.
</p>

<pre class="sh_java code-highlight"><code>ammukset.forEach(ammus -&gt; {
    List&lt;Asteroidi&gt; tormatyt = asteroidit.stream()
            .filter(asteroidi -&gt; asteroidi.tormaa(ammus))
            .collect(Collectors.toList());

    tormatyt.stream().forEach(tormatty -&gt; {
        asteroidit.remove(tormatty);
        ruutu.getChildren().remove(tormatty.getHahmo());
    });
});
</code></pre>

<img src="../img/material/ammus-poistaa-asteroidin-4caee5e2.gif" />

<p>&nbsp;</p>

<p>
  Ammukset eivät kuitenkaan poistu törmäyksen yhteydessä. Eräs tapa poistaa myös ammukset on esitelty seuraavassa esimerkissä.
</p>

<pre class="sh_java code-highlight"><code>List&lt;Ammus&gt; poistettavatAmmukset = ammukset.stream().filter(ammus -&gt; {
    List&lt;Asteroidi&gt; tormatyt = asteroidit.stream()
            .filter(asteroidi -&gt; asteroidi.tormaa(ammus))
            .collect(Collectors.toList());

    if(tormatyt.isEmpty()) {
        return false; 
    }
  
    tormatyt.stream().forEach(tormatty -&gt; {
        asteroidit.remove(tormatty);
        ruutu.getChildren().remove(tormatty.getHahmo());
    });
  
    return true;
}).collect(Collectors.toList());
  
poistettavatAmmukset.forEach(ammus -&gt; {
    ruutu.getChildren().remove(ammus.getHahmo());
    ammukset.remove(ammus);
});
</code></pre>

<p>
  Vaikka lähestymistapa toimii, voisi sitä ehkäpä parantaa hieman. Kyseessä on käytännössä hahmon "pelissä olemisen" määrittely. Hahmolle voisi esimerkiksi määritellä ominaisuuden "elossa", jota voisi hyödyntää edellä olevan selkeyttämiseen. Kyseisen muuttujan avulla ohjelma selkiytyy hieman.
</p>

<pre class="sh_java code-highlight"><code>ammukset.forEach(ammus -&gt; {
    asteroidit.forEach(asteroidi -&gt; {
        if(ammus.tormaa(asteroidi)) {
            ammus.setElossa(false);
            asteroidi.setElossa(false);
        }
    });
});

ammukset.stream()
        .filter(ammus -&gt; !ammus.isElossa())
        .forEach(ammus -&gt; ruutu.getChildren().remove(ammus.getHahmo()));
ammukset.removeAll(ammukset.stream()
        .filter(ammus -&gt; !ammus.isElossa())
        .collect(Collectors.toList()));
  
asteroidit.stream()
        .filter(asteroidi -&gt; !asteroidi.isElossa())
        .forEach(asteroidi -&gt; ruutu.getChildren().remove(asteroidi.getHahmo()));
asteroidit.removeAll(asteroidit.stream()
        .filter(asteroidi -&gt; !asteroidi.isElossa())
        .collect(Collectors.toList()));
</code></pre>

<p>
  Lopun riviparit ovat myös käytännössä identtiset -- kummatkin käsittelevät hahmoja. Ehkäpä tässä olisi lisäkohta refaktoroinnille.
</p>

<img src="../img/material/ammus-poistuu-7fcf23b5.gif" />

<p>&nbsp;</p>


<h2 class="material-heading">
    Pisteiden lisääminen

</h2>

<p>
  Lähes jokaiseen Asteroids-peliin kuuluu pisteiden seuraaminen. Pisteet kirjoitetaan ohjelmaan teksti-oliona, jonka arvoa muutetaan aina pisteiden muuttuessa. Sovitaan, että käyttäjä saa aina 1000 pistettä kun hän saa tuhottua asteroidin. 
</p>

<p>
  Javan tarjoama <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/text/Text.html" target="_blank">Text</a>-luokka on tähän tarkoitukseen mainio. Tekstioliolle määritellään koordinaatti sekä sisältö. Alla olevassa esimerkissä pisteet ovat aina 0.
</p>

<pre class="sh_java code-highlight"><code>@Override
public void start(Stage stage) throws Exception {
    Pane ruutu = new Pane();
    Text text = new Text(10, 20, "Points: 0");
    ruutu.getChildren().add(text);
  
    Scene scene = new Scene(ruutu);
    stage.setTitle("Asteroids!");
    stage.setScene(scene);
    stage.show();
}
</code></pre>


<img src="../img/material/asteroids-pisteet-483c60fc.png" alt="Ikkuna, jossa on teksti pisteet. Pisteet on nollassa."/>

<p>&nbsp;</p>

<p>
  Yllä olevassa esimerkissä pisteet ovat aina 0. Haluamme kuitenkin muuttuvat pisteet. Yksi näppärä väline tähän on luokka <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html" target="_blank">AtomicInteger</a>, joka tarjoaa kokonaisluvun kapseloituna oliona. AtomicInteger mahdollistaa myös pisteiden kasvattamisen metodikutsun yhteydessä.
</p>

<pre class="sh_java code-highlight"><code>@Override
public void start(Stage stage) throws Exception {
    Pane ruutu = new Pane();
    Text text = new Text(10, 20, "Points: 0");
    ruutu.getChildren().add(text);

    AtomicInteger pisteet = new AtomicInteger();
  
    Scene scene = new Scene(ruutu);
    stage.setTitle("Asteroids!");
    stage.setScene(scene);
    stage.show();


    new AnimationTimer() {

        @Override
        public void handle(long nykyhetki) {
            text.setText("Pisteet: " + pisteet.incrementAndGet());
        }
    }.start();
}
</code></pre>

<img src="../img/material/pisteet-kasvavat-9b2019b1.gif" alt="Ikkuna, jossa on teksti pisteet. Pisteet kasvavat."/>

<p>&nbsp;</p>

<p>
  Saamme siis pisteet näkyville ja pisteet kasvamaan. Kytketään pisteiden laskenta asteroids-peliin siten, että pisteitä tulee aina kun pelaajan ammus osuu asteroidiin.
</p>

<p>
  Tämän voi toteuttaa osana ammusten ja asteroidien törmäystä. 
</p>

<pre class="sh_java code-highlight"><code>ammukset.forEach(ammus -&gt; {
    asteroidit.forEach(asteroidi -&gt; {
        if(ammus.tormaa(asteroidi)) {
            ammus.setElossa(false);
            asteroidi.setElossa(false);
        }
    });

    if(!ammus.isElossa()) {
        text.setText("Points: " + pisteet.addAndGet(1000));
    } 
});
</code></pre>

<p>
  Nyt, olettaen että pisteiden kasvatus on poistettu animationtimerin alusta, pisteitä saa aina asteroidiin osuttaessa.
</p>

<img src="../img/material/asteroids-ammuskelua-ab6b0bcb.gif" alt="Like a boss."/>

<p>&nbsp;</p>


<h2 class="material-heading">
    Lisää asteroideja

</h2>

<p>
  Kun osumme asteroideihin, ne katoavat ja ammuttava loppuu kesken. Tämä ei ole hyväksyttävää!
</p>

<p>
  Lisätään ohjelmaan arpomistoiminnallisuus, mikä lisää asteroideja pelin edetessä. Asteroideja lisätään puolen prosentin todennäköisyydellä AnimationTimer-olion kutsujen yhteydessä. Tämän lisäksi uusi asteroidi lisätään vain mikäli se ei heti törmää alukseen.
</p>

<p>
  AnimationTimer-olion metodia handle kutsutaan noin 60 kertaa sekunnissa, joten uusia asteroideja tulee kymmenessä sekunnissa muutamia. Kutsu lisätään AnimationTimer-olion handle-metodin loppuun.
</p>

<pre class="sh_java code-highlight"><code>if(Math.random() &lt; 0.005) {
    Asteroidi asteroidi = new Asteroidi(LEVEYS, KORKEUS);
    if(!asteroidi.tormaa(alus)) {
        asteroidit.add(asteroidi);
        ruutu.getChildren().add(asteroidi.getHahmo());
    }
}
</code></pre>


<img src="../img/material/asteroids-ready-a0aff86b.gif" alt="Like a boss."/>

<p>&nbsp;</p>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Asteroids (11 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehtäväpohjassa on tyhjä ohjelmapohja. Toteuta tehtävään edellistä laajempaa esimerkkiä seuraten Asteroids-peli. Jokainen esimerkin alikohta (esim 2.3 ja 2.4) vastaa yhtä pelin osaa.
  </p>

  <p>
    Toteuta peliin siis kohdat:
  </p>

  <ol>
    <li>
      Peliruudun luominen
    </li>
    <li>
      Aluksen luominen
    </li>
    <li>
      Aluksen kääntäminen
    </li>
    <li>
      Aluksen liikuttaminen
    </li>
    <li>
      Asteroidin luominen
    </li>
    <li>
      Aluksen ja asteroidin törmääminen
    </li>
    <li>
      Useampi asteroidi
    </li>
    <li>
      Ruudussa pysyminen
    </li>
    <li>
      Ammukset
    </li>
    <li>
      Pisteiden lisääminen
    </li>
    <li>
      Lisää asteroideja
    </li>
  </ol>
  
  <p>
    Sitä mukaa kun toteutat peliä tehtäväpohjaan, päivitä luokan AsteroidsSovellus metodia <code>osiaToteutettu</code> palauttamaan valmiiksi saamasi osan numero. Voit palauttaa tehtävän vaikket tekisikään kaikkia osia, jolloin saat pisteitä tehtävän niistä osista, jotka olet tehnyt.
  </p>

  <p>
    Esimerkiksi, kun olet saanut aluksen kääntämisen toimimaan, olet vaiheessa 3, jolloin metodin <code>osiaToteutettu</code> tulisi palautta arvo <code>3</code>.
  </p>

  <p>
    Leppoisaa vääntöä! Kun saat tehtävän valmiiksi, saat toki jatkaa. Peliin voi lisätä esimerkisi ääniä ja erilaisia hahmoja -- miten esimerkiksi Ufot toimisivat pelissä? Voisivatko ne yrittää ampua hahmon alusta?
  </p>


    </div>
  </div>
</div>


<h1 class="material-heading">
    Sovellukset ohjelmointiympäristön ulkopuolella

</h1>


<p>
  Sovelluksemme ovat tähän mennessä toimineet vain ohjelmointiympäristössä. Tämä ei kuitenkaan ole käytännössä totta, sillä ohjelman käynnistäminen ohjelmointiympäristössä vastaa melko vahvasti sen käynnistämistä ohjelmointiympäristön ulkopuolella. Voimme määritellä luokan, jossa olevaa metodia <code>public static void main</code> käytetään ohjelman käynnistämiseen. 
</p>

<p>
  Mavenia ja JavaFX:ää käyttävien projektien "paketointiin" löytyy valmis Maven-liitännäinen <a href="http://javafx-maven-plugin.github.io/" target="_blank">http://javafx-maven-plugin.github.io/</a>. Liitännäinen tarjoaa muunmuassa mahdollisuuden sovelluksen paketointiin jar-tiedostoksi, minkä voi suorittaa suoraan komentoriviltä.
</p>

<p>
  Liitännäisen käyttöönotto tapahtuu lisäämällä projektin <code>pom.xml</code>-tiedostoon tieto ohjelman käännöksen aikana suoritettavasta liitännäisestä. 
</p>

<pre class="sh_xml code-highlight"><code>&lt;build&gt;
  &lt;plugins&gt;
      
    &lt;plugin&gt;
      &lt;groupId&gt;com.zenjava&lt;/groupId&gt;
      &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;8.6.0&lt;/version&gt;
      &lt;configuration&gt;
        &lt;mainClass&gt;asteroids.AsteroidsSovellus&lt;/mainClass&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
      
  &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>
  Nyt kun sovelluksen paketoi erillisen <code>mvn jfx:jar</code>-kutsun avulla, projektista luodaan jar-tiedosto, jonka voi käynnistää komentoriviltä.
</p>

<p>
Kutsun voi antaa NetBeansissa klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Run Maven -&gt; Goals...". Tämän jälkeen avautuvaan ikkunaan syötetään kohtaan "Goals" merkkijono "jfx:jar". Kun tämän jälkeen painetaan ok, sovelluksesta luodaan valmis paketti.
</p>


<p>
  NetBeansin Output-välilehti antaa vinkkiä sovelluksen suorittamisesta.
</p>

<pre class="sample-output">// ...
--- javafx-maven-plugin:8.6.0:jar (default-cli) @ Osa13_04.Asteroids ---
Building JavaFX JAR for application
Adding 'deploy' directory to Mojo classpath: ...
</pre>


<p>
  Jos kaikki menee hyvin, sovelluksen kansiosta <code>target</code> löytyy alikansio <code>jfx</code>. Tämän alla on kansio <code>app</code>, joka sisältää suoritettavan jar-päätteisen tiedoston.
</p>

<p>
  Nyt sovelluksen voi käynnistää komentoriviltä. Kun annamme komentorivillä komennon "java -jar" -- eli, käynnistä jar-paketoitu ohjelma Javalla, jota seuraa yllä luotu jar-tiedosto, käynnistyy ohjelma.
</p>

<pre>
$ java -jar "/<em>polku</em>/osa13/Osa13_04.Asteroids/target/jfx/app/Osa13_04.Asteroids-1.0-SNAPSHOT.jar"
</pre>

<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Asennettavan sovelluksen luominen
  </div>

  <div class="hint__body">
    
  <p>
    Edellä kuvattu menetelmä paketoi sovelluksen suoritettavaan muotoon. Tietokoneiden normaalikäyttäjät eivät kuitenkaan ole tottuneet sovellusten käynnistämiseen komentoriviltä -- osalla heistä ei myöskään ole Javaa asennettuna, jonka edellinen komento vaatii.
  </p>

  <p>
    Sovellusten paketointiin ja tuotteistamiseen ym. syvennytään laajemmin mm. kursseilla ohjelmistotekniikan menetelmät ja ohjelmistotuotanto.
  </p>
  

  </div>
</div>


<div class="quiznator-plugin" data-quiz-id="5a25a1ff1bbf3a0004538a89"></div>




        </div>
      </div>

      <div class="footer-wrapper">
        <footer class="footer">
  <div>
    Tämä materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssillä
  </div>
  <div>
    Kurssin on tehnyt Helsingin Yliopiston Agile Education Research -tutkimusryhmä.
  </div>
  <div class="improvement">
    <a href="https://github.com/materiaalit/ohjelmointi-s17/issues/new"  target="_blank" rel="noopener">
  <button class='btn btn-primary'>
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i> Ilmoita virhe
  </button>
</a>
<a href="https://github.com/materiaalit/ohjelmointi-s17/edit/master/source/part13.html.erb" target="_blank" rel="noopener">
  <button class='btn btn-primary'>
    <i class="fa fa-pencil" aria-hidden="true"></i>
 Muokkaa sivua
  </button>
</a>
     <a href="https://github.com/materiaalit/ohjelmointi-s17" class="footer__github-link" target="_blank" rel="noopener">
      <i class="fa fa-github"></i>
    </a>
  </div>
</footer>

      </div>
    </div>

    <div class="modal fade" id="tmc-login-modal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <form id="tmc-login-form">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title">Kirjaudu TMC-käyttäjällesi</h4>
        </div>
        <div class="modal-body">
          <div class="alert alert-info">
            Puuttuuko sinulta TMC-käyttäjätunnus? <a href="https://tmc.mooc.fi/user/new" class="alert-link" target="_blank" rel="noopener">Rekisteröidy</a>
          </div>

          <div class="alert alert-danger" id="tmc-login-error" style="display: none;"></div>

          <div class="form-group">
            <label>Käyttäjätunnus</label>
            <input type="text" id="tmc-login-username" class="form-control" placeholder="Käyttäjätunnus"/>
          </div>

          <div class="form-group">
            <label>Salasana</label>
            <input type="password" id="tmc-login-password" class="form-control" placeholder="Salasana"/>
          </div>

          <div class="form-group">
            <label>Kurssi</label>

            <div class="form-check">
              <label class="form-check-label">
                <input type="radio" class="form-check-input" name="tmcLoginCourse" value="hy-ohpe-s17">
                hy-ohpe-s17 (Ohjelmoinnin perusteet, syksy 2017)
              </label>
            </div>

	    <div class="form-check">
              <label class="form-check-label">
                <input type="radio" class="form-check-input" name="tmcLoginCourse" value="hy-ohja-s17">
                hy-ohja-s17 (Ohjelmoinnin jatkokurssi, syksy 2017)
              </label>
            </div>

            <small class="form-text text-muted">
              Kurssin valinnalla on pieniä vaikutuksia materiaalin tiettyihin osiin.
            </small>
          </div>
        </div>
        <div class="modal-footer">
          <a class="btn btn-secondary" data-dismiss="modal">Sulje</a>
          <button type="submit" class="btn btn-primary">Kirjaudu sisään</button>
        </div>
      </form>
    </div>
  </div>
</div>


    <div class="table-of-contents-layer" id="table-of-contents-layer">
</div>

<div class="table-of-contents" id="table-of-contents">
  <h1 class="table-of-contents__heading">
    Sisällysluettelo
  </h1>

  <div class="table-of-contents__content">
    <ul id="table-of-contents-list"></ul>
  </div>
</div>


    <script>
  window._QUIZNATOR_ENABLED = true;
</script>

<script src="https://quiznator.herokuapp.com/javascripts/plugin-loader.min.js"></script>


    <script>
  window._STUDENT_DASHBOARD_ENABLED = true;
</script>
<script src="https://student-dashboard.testmycode.io/plugin-loader/script.js"></script>


    <script src="https://code.jquery.com/jquery-3.1.1.min.js"
	    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
	    crossorigin="anonymous"></script>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script>
      window.SD_SHOW_SURVEY = ['part6', 'part7'].indexOf(window.location.pathname.replace(/\//g,'')) >= 0;
    </script>

    <script src="../javascripts/scripts-57bcb25a.js"></script>

    <script src="https://use.fontawesome.com/ed2f73836b.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.js"></script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js'></script>

    <script>window.cookieconsent.initialise({"palette":{"popup":{"background":"#000"},"button":{"background":"#f1d600"}}, "position": "bottom-left"});</script>

    <script src='https://materiaalit.github.io/code-states-visualizer-cdn/app.js'></script>
    <script src='https://materiaalit.github.io/typonator-cdn/app.js'></script>
    <script src='https://crowdsorcerer.testmycode.io/dist/app.js'></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        window.initCodeStatesVisualizer();
        // window.initTyponator(); // default init disabled -- favoring AB
        window.initCrowdsorcerer();
      });
    </script>
  </body>
</html>
